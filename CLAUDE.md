# 50Pfennig — Claude Code Source of Truth

Shared expense splitting app for small trust-based groups (2–10 people).
React + Capacitor hybrid (Android-first, iOS later). German UI (de default, en secondary).

Full architectural rationale lives in [docs/adr/](docs/adr/).

---

## Tech Stack

| Concern | Choice |
|---|---|
| Framework | React 18 + TypeScript (strict) + Vite |
| Mobile | Capacitor (Android now, iOS later) |
| Backend | Supabase — Postgres + Auth + Realtime + RLS |
| UI | Tailwind CSS + shadcn/ui + Lucide icons |
| Server state | TanStack Query v5 |
| Local/UI state | Zustand |
| Routing | TanStack Router v1 |
| Forms | React Hook Form + Zod |
| Linting/formatting | Biome |
| Dates | date-fns |
| i18n | i18next + react-i18next (de default, en) |
| Testing | Vitest — domain layer only |
| Package manager | npm |

---

## Project Structure

```
src/
├── domain/          # Pure TypeScript — ZERO deps on React, Supabase, or any library
│   ├── types.ts     # All domain types (Money, Expense, Settlement, Group, etc.)
│   ├── money.ts     # Money arithmetic: add, subtract, allocate (largest-remainder)
│   ├── splitting/   # splitExpense() — equal / exact / percentage
│   └── balance/     # calculateGroupBalances(), simplifyDebts()
│
├── lib/             # Infrastructure adapters (impure, side-effectful)
│   ├── supabase/
│   │   ├── client.ts        # Supabase client singleton
│   │   ├── types.gen.ts     # DO NOT EDIT — generated by `npm run db:types`
│   │   └── mappers.ts       # DB row → domain type conversions
│   ├── storage/
│   │   ├── offlineQueue.ts  # Zustand mutation queue, persisted to IndexedDB
│   │   ├── queryPersister.ts
│   │   └── syncService.ts   # Flushes queue on connectivity restore
│   └── capacitor/
│       └── network.ts       # Capacitor Network plugin wrapper
│
├── repositories/    # Data access abstraction — features never call Supabase directly
│   ├── types.ts     # IGroupRepository, IExpenseRepository, ISettlementRepository
│   ├── supabase/    # Concrete Supabase implementations
│   └── index.ts     # Factory / binding
│
├── features/        # Self-contained feature modules
│   ├── auth/        # components/, hooks/, authStore.ts
│   ├── groups/      # components/, hooks/, groupQueries.ts
│   ├── expenses/    # components/SplitEditor/ (equal/exact/percentage sub-components)
│   ├── settlements/
│   └── balances/    # Derived display — no fetches, uses TQ cache data only
│
├── pages/           # Route-level components — thin wrappers, no business logic
├── components/
│   ├── ui/          # shadcn/ui generated components — DO NOT EDIT manually
│   └── shared/      # MoneyDisplay, UserAvatar, EmptyState, etc.
├── store/
│   ├── uiStore.ts   # selectedGroupId, activeSheet, expenseFormDraft
│   └── offlineStore.ts
└── router/
    ├── index.tsx    # TanStack Router route tree
    └── guards.tsx   # Auth guard

supabase/
└── migrations/      # SQL files — schema, RLS policies, RPC functions

public/
└── locales/
    ├── de/translation.json   # German (default)
    └── en/translation.json   # English
```

---

## Dependency Rule — Non-Negotiable

```
domain/       →  imports NOTHING outside src/domain/
repositories/ →  imports from domain/ and lib/supabase/ only
features/     →  imports from domain/, repositories/, store/, components/
pages/        →  imports from features/ and router/ only
```

If you find yourself importing Supabase inside a feature hook, stop — use the repository instead.
If you find yourself importing React inside `domain/`, stop — it must stay pure.

---

## Architectural Rules

### Money
- All monetary values are `Money` (integer cents, branded type). €12.50 = `money(1250)`.
- Never use raw `number` where `Money` is expected. The branded type catches this at compile time.
- Use `allocate(total, ratios)` for any split calculation — it uses the largest-remainder method so results always sum exactly to the original. Never write manual rounding logic.
- Percentages are stored as **basis points** (0–10000). 33.33% = `3333`. Validation: `sum === 10000`.
- Display: always use `formatMoney(m)` from `src/domain/money.ts`. Never format cents manually.

### Balances
- **Balances are never stored in the database.** Never add a `balance` column to any table.
- Balances are always derived in the client from TanStack Query cached data using `calculateGroupBalances()`.
- The `balances/` feature has no fetches of its own — it reads from the groups/expenses/settlements query cache.

### Expense writes
- Creating or updating an expense always calls `supabase.rpc('create_expense', {...})` — never two separate inserts.
- The RPC function inserts `expenses` + `expense_splits` atomically in one Postgres transaction.
- The `expense_splits` rows are the computed snapshot of the split algorithm at write time. They are immutable financial history.

### Repositories
- Features call `IExpenseRepository`, `IGroupRepository`, etc. — never the Supabase client directly.
- Offline mutation queue logic lives inside repository implementations, not in feature hooks.
- Adding a new data operation: add to the interface in `repositories/types.ts` first, then implement.

---

## State Management Rules

**TanStack Query** owns all server state:
```
["groups"]                 → list of groups for current user
["groups", groupId]        → single group with members
["expenses", groupId]      → all expenses for a group
["settlements", groupId]   → all settlements for a group
["currentUser"]            → authenticated user profile
```
- Use a `queryKey` factory function in each feature's `*Queries.ts` file — never inline the key array.
- All mutations use `onMutate` / `onError` / `onSettled` for optimistic updates.
- Cache is persisted to IndexedDB (7-day TTL). Works offline.

**Zustand** owns UI and device-local state:
```
uiStore:     selectedGroupId, activeSheet, expenseFormDraft
offlineStore: mutation queue (persisted to IndexedDB)
authStore:   session, isHydrated
```

**Never put in Zustand:** group/expense/settlement data, computed balances, navigation history.
**Never put in TanStack Query:** UI state, auth session, offline queue.

---

## Naming Conventions

| Thing | Convention | Example |
|---|---|---|
| React components | PascalCase | `ExpenseForm.tsx`, `GroupCard.tsx` |
| Hooks | camelCase, `use` prefix | `useGroupBalances.ts` |
| Zustand stores | camelCase, `Store` suffix | `uiStore.ts`, `authStore.ts` |
| Query key factories | camelCase, `QueryOptions` suffix | `expenseQueryOptions(groupId)` |
| Repository interfaces | PascalCase, `I` prefix | `IExpenseRepository` |
| Domain pure functions | camelCase, verb-first | `splitExpense()`, `calculateGroupBalances()` |
| DB migration files | `NNNN_description.sql` | `0001_initial_schema.sql` |
| ADR files | `NNNN-kebab-title.md` | `0006-atomic-expense-creation-via-rpc.md` |
| i18n keys | dot notation, feature-scoped | `expenses.form.description_placeholder` |

---

## Coding Patterns

### Adding a new feature
1. Define/extend types in `src/domain/types.ts` if needed
2. Add interface methods to `src/repositories/types.ts`
3. Implement in `src/repositories/supabase/`
4. Write query key factory + fetcher in `src/features/<feature>/<feature>Queries.ts`
5. Write TanStack Query hooks in `src/features/<feature>/hooks/`
6. Build components in `src/features/<feature>/components/`
7. Add route + page in `src/router/` and `src/pages/`
8. Add i18n keys to both `de/translation.json` and `en/translation.json`

### Writing a TanStack Query hook
```typescript
// Always use queryKey factory, never inline
export const expenseQueryOptions = (groupId: GroupId) =>
  queryOptions({
    queryKey: ["expenses", groupId],
    queryFn: () => expenseRepository.getByGroupId(groupId),
  });

export const useExpenses = (groupId: GroupId) =>
  useQuery(expenseQueryOptions(groupId));
```

### Writing a mutation with optimistic update
```typescript
export const useCreateExpense = () => {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (input: CreateExpenseInput) => expenseRepository.create(input),
    onMutate: async (input) => {
      await queryClient.cancelQueries({ queryKey: ["expenses", input.groupId] });
      const previous = queryClient.getQueryData(["expenses", input.groupId]);
      queryClient.setQueryData(["expenses", input.groupId], (old) => [...(old ?? []), optimisticExpense(input)]);
      return { previous };
    },
    onError: (_err, input, ctx) => {
      queryClient.setQueryData(["expenses", input.groupId], ctx?.previous);
    },
    onSettled: (_data, _err, input) => {
      queryClient.invalidateQueries({ queryKey: ["expenses", input.groupId] });
    },
  });
};
```

### Writing a Zod schema for a form
```typescript
// Co-locate schema with the form component
export const createExpenseSchema = z.object({
  description: z.string().min(1).max(200),
  totalAmount: z.number().int().positive(), // cents
  paidBy: z.string().uuid(),
  splitType: z.enum(["equal", "exact", "percentage"]),
  // ... split-specific fields
});
export type CreateExpenseFormValues = z.infer<typeof createExpenseSchema>;
```

### Using i18n
```typescript
// Always use the hook — never hardcode user-visible strings
const { t } = useTranslation();
return <p>{t("expenses.form.description_placeholder")}</p>;

// In translation.json files, mirror the feature structure:
// { "expenses": { "form": { "description_placeholder": "Was wurde bezahlt?" } } }
```

### Deriving balances in a component
```typescript
// No fetch — derive from cached data
const { data: expenses } = useExpenses(groupId);
const { data: settlements } = useSettlements(groupId);
const { data: group } = useGroup(groupId);

const balances = useMemo(
  () => expenses && settlements && group
    ? calculateGroupBalances(expenses, settlements, group.members)
    : null,
  [expenses, settlements, group]
);
```

---

## Testing

- **Only `src/domain/` is unit tested.**
- Test files co-located: `src/domain/splitting/splitting.test.ts`
- Run: `npm test` — Vitest, `environment: "node"` (no DOM needed)
- Coverage thresholds: lines ≥ 90%, functions ≥ 90%, branches ≥ 85%
- Every public function in `domain/` must have tests covering: happy path, edge cases (zero, single participant, non-divisible amounts), and validation errors.
- Do not test React components, hooks, or repository implementations with unit tests in V1.

---

## Common Commands

```bash
npm run dev           # Start Vite dev server
npm run build         # Production build (output: dist/)
npm test              # Run domain unit tests
npm run test:coverage # With coverage report
npm run lint          # Biome lint
npm run format        # Biome format

npm run db:start      # Start local Supabase (Docker required)
npm run db:stop       # Stop local Supabase
npm run db:types      # Regenerate src/lib/supabase/types.gen.ts from schema
npm run db:migrate    # Push migrations to local Supabase
npm run db:reset      # Reset local DB and re-run all migrations

npx cap sync android  # Sync web build to Android project (run after npm run build)
npx cap open android  # Open Android Studio
```

---

## Files Never to Edit Manually

- `src/lib/supabase/types.gen.ts` — always regenerated by `npm run db:types`
- `src/components/ui/*.tsx` — shadcn/ui components, always added/updated via `npx shadcn@latest add`
- `android/` — managed by Capacitor, always updated via `npx cap sync`

---

## Key Invariants (things that must always be true)

1. `sum(expense_splits.amount) === expenses.total_amount` for every expense
2. `sum(expense.split.basisPoints) === 10000` for every percentage split
3. No balance columns exist in any database table
4. Every user-visible string goes through `t('key')` — no hardcoded strings
5. `src/domain/` has zero imports from outside itself
6. Expense + splits are always written in a single Postgres transaction (via RPC)
