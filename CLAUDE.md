# 50Pfennig — Claude Code Source of Truth

Shared expense splitting app for small trust-based groups (2–10 people).
React + Capacitor hybrid (Android-first, iOS later). German UI (de default, en secondary).

Full architectural rationale lives in [docs/adr/](docs/adr/).

---

## Tech Stack

| Concern | Choice |
|---|---|
| Framework | React 18 + TypeScript (strict) + Vite |
| Mobile | Capacitor (Android now, iOS later) |
| Backend | Supabase — Postgres + Auth + Realtime + RLS |
| UI | Tailwind CSS + shadcn/ui + Lucide icons |
| Server state | TanStack Query v5 |
| Local/UI state | Zustand |
| Routing | TanStack Router v1 |
| Forms | React Hook Form + Zod |
| Linting/formatting | Biome |
| Dates | date-fns |
| i18n | i18next + react-i18next (de default, en) |
| Testing | Vitest — domain layer only |
| Package manager | npm |

---

## Project Structure

```
src/
├── domain/          # Pure TypeScript — ZERO deps on React, Supabase, or any library
│   ├── types.ts     # All domain types (Money, Expense, Settlement, Group, etc.)
│   ├── money.ts     # Money arithmetic: add, subtract, allocate (largest-remainder)
│   ├── splitting/   # splitExpense() — equal / exact / percentage
│   └── balance/     # calculateGroupBalances(), simplifyDebts()
│
├── lib/             # Infrastructure adapters (impure, side-effectful)
│   ├── supabase/
│   │   ├── client.ts        # Supabase client singleton
│   │   ├── types.gen.ts     # DO NOT EDIT — generated by `npm run db:types`
│   │   └── mappers.ts       # DB row → domain type conversions
│   ├── storage/
│   │   ├── offlineQueue.ts  # Zustand mutation queue, persisted to IndexedDB
│   │   ├── queryPersister.ts
│   │   └── syncService.ts   # Flushes queue on connectivity restore
│   └── capacitor/
│       └── network.ts       # Capacitor Network plugin wrapper
│
├── repositories/    # Data access abstraction — features never call Supabase directly
│   ├── types.ts     # IGroupRepository, IExpenseRepository, ISettlementRepository
│   ├── supabase/    # Concrete Supabase implementations
│   └── index.ts     # Factory / binding
│
├── features/        # Self-contained feature modules
│   ├── auth/        # components/, hooks/, authStore.ts
│   ├── groups/      # components/, hooks/, groupQueries.ts
│   ├── expenses/    # components/SplitEditor/ (equal/exact/percentage sub-components)
│   ├── settlements/
│   └── balances/    # Derived display — no fetches, uses TQ cache data only
│
├── pages/           # Route-level components — thin wrappers, no business logic
├── components/
│   ├── ui/          # shadcn/ui generated components — DO NOT EDIT manually
│   └── shared/      # MoneyDisplay, UserAvatar, EmptyState, etc.
├── store/
│   ├── uiStore.ts   # selectedGroupId, activeSheet, expenseFormDraft
│   └── offlineStore.ts
└── router/
    ├── index.tsx    # TanStack Router route tree
    └── guards.tsx   # Auth guard

supabase/
└── migrations/      # SQL files — schema, RLS policies, RPC functions

public/
└── locales/
    ├── de/translation.json   # German (default)
    └── en/translation.json   # English
```

---

## Implementation Status

These files exist as documented stubs — they export empty objects/null and are **not yet implemented**:

- `src/features/groups/groupQueries.ts`
- `src/features/expenses/expenseQueries.ts`
- `src/features/balances/hooks/useGroupBalances.ts`
- `src/lib/storage/offlineQueue.ts`
- `src/lib/storage/syncService.ts`
- `src/components/shared/MoneyDisplay.tsx` (returns null)

Most feature-level hooks and components are scaffolds. The fully implemented foundation is: domain layer, repository implementations, database schema, auth, routing, and stores.

---

## Path Aliases

Configured in `vite.config.ts` and `tsconfig.app.json`. Always prefer aliases over relative `../` imports.

| Alias | Resolves to |
|---|---|
| `@/*` | `src/*` |
| `@domain/*` | `src/domain/*` |
| `@lib/*` | `src/lib/*` |
| `@repositories/*` | `src/repositories/*` |
| `@features/*` | `src/features/*` |
| `@pages/*` | `src/pages/*` |
| `@components/*` | `src/components/*` |
| `@store/*` | `src/store/*` |
| `@router/*` | `src/router/*` |

---

## Dependency Rule — Non-Negotiable

```
domain/       →  imports NOTHING outside src/domain/
repositories/ →  imports from domain/ and lib/supabase/ only
features/     →  imports from domain/, repositories/, store/, components/
pages/        →  imports from features/ and router/ only
```

If you find yourself importing Supabase inside a feature hook, stop — use the repository instead.
If you find yourself importing React inside `domain/`, stop — it must stay pure.

---

## Routes

| Path | Component | Guard |
|---|---|---|
| `/login` | `LoginPage` | `requireGuest` — redirects to `/groups` if already authed |
| `/groups` | `GroupsPage` | `requireAuth` |
| `/groups/:groupId` | `GroupDetailPage` | `requireAuth` |
| `/groups/:groupId/expenses/new` | `ExpenseFormPage` (create) | `requireAuth` |
| `/groups/:groupId/expenses/:expenseId/edit` | `ExpenseFormPage` (edit) | `requireAuth` |
| `/groups/:groupId/settlements` | `SettlementsPage` | `requireAuth` |
| `/balances` | `BalancesPage` | `requireAuth` |
| `/account` | `AccountPage` | `requireAuth` |

Guards (`src/router/guards.tsx`) run in TanStack Router's `beforeLoad`. They call `useAuthStore.getState()` (not the hook) and `throw redirect(...)`.

---

## Architectural Rules

### Money
- All monetary values are `Money` (integer cents, branded type). €12.50 = `money(1250)`.
- Never use raw `number` where `Money` is expected. The branded type catches this at compile time.
- Use `allocate(total, ratios)` for any split calculation — it uses the largest-remainder method so results always sum exactly to the original. Never write manual rounding logic.
- Percentages are stored as **basis points** (0–10000). 33.33% = `3333`. Validation: `sum === 10000`.
- Display: always use `formatMoney(m)` from `src/domain/money.ts`. Never format cents manually.

### Balances
- **Balances are never stored in the database.** Never add a `balance` column to any table.
- Balances are always derived in the client from TanStack Query cached data using `calculateGroupBalances()`.
- The `balances/` feature has no fetches of its own — it reads from the groups/expenses/settlements query cache.

### Expense writes
- Creating or updating an expense always calls `supabase.rpc('create_expense', {...})` — never two separate inserts.
- The RPC function inserts `expenses` + `expense_splits` atomically in one Postgres transaction.
- The `expense_splits` rows are the computed snapshot of the split algorithm at write time. They are immutable financial history.

**RPC signatures** (always call through repository, never directly in features):
```typescript
supabase.rpc('create_expense', {
  p_group_id:    GroupId,
  p_description: string,
  p_total_amount: number,                              // cents
  p_paid_by:     UserId,
  p_split_type:  'equal' | 'exact' | 'percentage',
  p_split_config: Json,                               // serialiseSplitConfig(split)
  p_splits: { user_id: string; amount: number }[],   // serialiseSplits(splitResult)
})  // → returns expense row

supabase.rpc('update_expense', {
  p_expense_id: ExpenseId,
  // + same remaining params as create_expense
})  // → returns expense row
```
After calling either RPC, fetch splits separately:
```typescript
supabase.from('expense_splits').select('*').eq('expense_id', id)
```

**Serializer utilities** (in `src/lib/supabase/mappers.ts`):
- `serialiseSplitConfig(split: ExpenseSplit): Json`
- `serialiseSplits(splits: Record<UserId, Money>): { user_id: string; amount: number }[]`

### ExpenseSplit (discriminated union)
```typescript
type EqualSplit      = { type: 'equal' }
type ExactSplit      = { type: 'exact'; amounts: Record<UserId, Money> }
type PercentageSplit = { type: 'percentage'; basisPoints: Record<UserId, number> }
type ExpenseSplit    = EqualSplit | ExactSplit | PercentageSplit
```
- `split_config` (JSONB) stores the full `ExpenseSplit`.
- `split_type` column mirrors the `type` field for SQL indexing.

### Repositories
- Features call `IExpenseRepository`, `IGroupRepository`, etc. — never the Supabase client directly.
- Offline mutation queue logic lives inside repository implementations, not in feature hooks.
- Adding a new data operation: add to the interface in `repositories/types.ts` first, then implement.

---

## Database Schema

> Source of truth: `supabase/migrations/0001_initial_schema.sql`. All monetary columns are **integer cents**.

### `groups`
| column | type | notes |
|---|---|---|
| id | uuid PK | |
| name | text | 1–100 chars |
| created_by | uuid FK auth.users | |
| created_at | timestamptz | |

### `group_members`
| column | type | notes |
|---|---|---|
| user_id | uuid FK auth.users | composite PK |
| group_id | uuid FK groups | composite PK, cascade |
| display_name | text | 1–80 chars |
| joined_at | timestamptz | |

### `expenses`
| column | type | notes |
|---|---|---|
| id | uuid PK | |
| group_id | uuid FK groups | cascade |
| description | text | 1–200 chars |
| total_amount | integer | cents > 0 |
| paid_by | uuid FK auth.users | |
| split_type | enum | `'equal'` \| `'exact'` \| `'percentage'` |
| split_config | jsonb | serialized `ExpenseSplit` |
| created_by | uuid FK auth.users | |
| created_at | timestamptz | |
| updated_at | timestamptz | auto-updated by trigger |

### `expense_splits`
| column | type | notes |
|---|---|---|
| id | uuid PK | |
| expense_id | uuid FK expenses | cascade |
| user_id | uuid FK auth.users | unique with expense_id |
| amount | integer | cents ≥ 0 |

### `settlements`
| column | type | notes |
|---|---|---|
| id | uuid PK | |
| group_id | uuid FK groups | cascade |
| from_user_id | uuid FK auth.users | payer (≠ to_user_id) |
| to_user_id | uuid FK auth.users | receiver |
| amount | integer | cents > 0 |
| note | text | nullable |
| created_at | timestamptz | |

### RLS & helpers
- All tables have RLS enabled. Access is gated on `is_group_member(group_id)` (SECURITY DEFINER function).
- Never bypass RLS by using a service role key in feature code.

---

## State Management Rules

**TanStack Query** owns all server state:
```
["groups"]                 → list of groups for current user
["groups", groupId]        → single group with members
["expenses", groupId]      → all expenses for a group
["settlements", groupId]   → all settlements for a group
["currentUser"]            → authenticated user profile
```
- Use a `queryKey` factory function in each feature's `*Queries.ts` file — never inline the key array.
- All mutations use `onMutate` / `onError` / `onSettled` for optimistic updates.
- Cache is persisted to IndexedDB (7-day TTL). Works offline.

**Zustand** owns UI and device-local state:

`authStore` (`src/features/auth/authStore.ts`):
```typescript
session:     Session | null   // null = not signed in
isHydrated:  boolean          // false until first onAuthStateChange fires
setSession:  (s: Session | null) => void
setHydrated: () => void
```
> Outside React (route guards, sync service): `useAuthStore.getState().session` — not the hook.

`uiStore` (`src/store/uiStore.ts`):
```typescript
selectedGroupId:    GroupId | null
activeSheet:        'add-expense' | 'record-settlement' | 'add-member' | null
setSelectedGroupId: (id: GroupId | null) => void
openSheet:          (sheet: NonNullable<typeof activeSheet>) => void
closeSheet:         () => void
```

`offlineStore`: mutation queue — **not yet implemented** (see `src/lib/storage/offlineQueue.ts` stub for the planned `QueuedMutation` shape).

**Never put in Zustand:** group/expense/settlement data, computed balances, navigation history.
**Never put in TanStack Query:** UI state, auth session, offline queue.

---

## Naming Conventions

| Thing | Convention | Example |
|---|---|---|
| React components | PascalCase | `ExpenseForm.tsx`, `GroupCard.tsx` |
| Hooks | camelCase, `use` prefix | `useGroupBalances.ts` |
| Zustand stores | camelCase, `Store` suffix | `uiStore.ts`, `authStore.ts` |
| Query key factories | camelCase, `QueryOptions` suffix | `expenseQueryOptions(groupId)` |
| Repository interfaces | PascalCase, `I` prefix | `IExpenseRepository` |
| Domain pure functions | camelCase, verb-first | `splitExpense()`, `calculateGroupBalances()` |
| DB migration files | `NNNN_description.sql` | `0001_initial_schema.sql` |
| ADR files | `NNNN-kebab-title.md` | `0006-atomic-expense-creation-via-rpc.md` |
| i18n keys | dot notation, feature-scoped | `expenses.form.description_placeholder` |

---

## Coding Patterns

### Adding a new feature
1. Define/extend types in `src/domain/types.ts` if needed
2. Add interface methods to `src/repositories/types.ts`
3. Implement in `src/repositories/supabase/`
4. Write query key factory + fetcher in `src/features/<feature>/<feature>Queries.ts`
5. Write TanStack Query hooks in `src/features/<feature>/hooks/`
6. Build components in `src/features/<feature>/components/`
7. Add route + page in `src/router/` and `src/pages/`
8. Add i18n keys to both `de/translation.json` and `en/translation.json`

### Writing a TanStack Query hook
```typescript
// Always use queryKey factory, never inline
export const expenseQueryOptions = (groupId: GroupId) =>
  queryOptions({
    queryKey: ["expenses", groupId],
    queryFn: () => expenseRepository.getByGroupId(groupId),
  });

export const useExpenses = (groupId: GroupId) =>
  useQuery(expenseQueryOptions(groupId));
```

### Writing a mutation with optimistic update
```typescript
export const useCreateExpense = () => {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (input: CreateExpenseInput) => expenseRepository.create(input),
    onMutate: async (input) => {
      await queryClient.cancelQueries({ queryKey: ["expenses", input.groupId] });
      const previous = queryClient.getQueryData(["expenses", input.groupId]);
      queryClient.setQueryData(["expenses", input.groupId], (old) => [...(old ?? []), optimisticExpense(input)]);
      return { previous };
    },
    onError: (_err, input, ctx) => {
      queryClient.setQueryData(["expenses", input.groupId], ctx?.previous);
    },
    onSettled: (_data, _err, input) => {
      queryClient.invalidateQueries({ queryKey: ["expenses", input.groupId] });
    },
  });
};
```

### Writing a Zod schema for a form
```typescript
// Co-locate schema with the form component
export const createExpenseSchema = z.object({
  description: z.string().min(1).max(200),
  totalAmount: z.number().int().positive(), // cents
  paidBy: z.string().uuid(),
  splitType: z.enum(["equal", "exact", "percentage"]),
  // ... split-specific fields
});
export type CreateExpenseFormValues = z.infer<typeof createExpenseSchema>;
```

### Using i18n
```typescript
// Always use the hook — never hardcode user-visible strings
const { t } = useTranslation();
return <p>{t("expenses.form.description_placeholder")}</p>;

// In translation.json files, mirror the feature structure:
// { "expenses": { "form": { "description_placeholder": "Was wurde bezahlt?" } } }
```

### Writing a DB mapper (`src/lib/supabase/mappers.ts`)

Mappers are pure functions — no DB calls inside, ever.

```typescript
import type { Database } from '@lib/supabase/types.gen';
type GroupMemberRow = Database['public']['Tables']['group_members']['Row'];

export const mapGroupMember = (row: GroupMemberRow): GroupMember => ({
  userId:      row.user_id  as UserId,   // always cast DB strings to branded ID types
  groupId:     row.group_id as GroupId,
  displayName: row.display_name,
  joinedAt:    new Date(row.joined_at),  // convert ISO string → Date
});
```

Key patterns:
- **Cent columns**: `money(row.total_amount)` — never assign raw integer to `Money`
- **JSONB columns**: `row.split_config as unknown as ExpenseSplit`
- **Optional fields**: `...(row.note != null ? { note: row.note } : {})`
- **Joins**: `supabase.from('x').select('*, related(*)')` then cast `(row as typeof row & { related: unknown[] })`
- **User display name**: `user.user_metadata?.['display_name'] ?? user.email ?? user.id`

### Deriving balances in a component
```typescript
// No fetch — derive from cached data
const { data: expenses } = useExpenses(groupId);
const { data: settlements } = useSettlements(groupId);
const { data: group } = useGroup(groupId);

const balances = useMemo(
  () => expenses && settlements && group
    ? calculateGroupBalances(expenses, settlements, group.members)
    : null,
  [expenses, settlements, group]
);
```

---

## Testing

- **Only `src/domain/` is unit tested.**
- Test files co-located: `src/domain/splitting/splitting.test.ts`
- Run: `npm test` — Vitest, `environment: "node"` (no DOM needed)
- Coverage thresholds: lines ≥ 90%, functions ≥ 90%, branches ≥ 85%
- Every public function in `domain/` must have tests covering: happy path, edge cases (zero, single participant, non-divisible amounts), and validation errors.
- Do not test React components, hooks, or repository implementations with unit tests in V1.

---

## Common Commands

**Environment variables** — create `.env.local` (git-ignored, never committed):
```
VITE_SUPABASE_URL=https://your-project.supabase.co
VITE_SUPABASE_ANON_KEY=your-anon-key
```
For local dev: run `npm run db:start`, then `supabase status` to get the URL and anon key.

```bash
npm run dev           # Start Vite dev server
npm run build         # Production build (output: dist/)
npm test              # Run domain unit tests
npm run test:coverage # With coverage report
npm run lint          # Biome lint
npm run format        # Biome format

npm run db:start      # Start local Supabase (Docker required)
npm run db:stop       # Stop local Supabase
npm run db:types      # Regenerate src/lib/supabase/types.gen.ts from schema
npm run db:migrate    # Push migrations to local Supabase
npm run db:reset      # Reset local DB and re-run all migrations

npx cap sync android  # Sync web build to Android project (run after npm run build)
npx cap open android  # Open Android Studio
```

---

## Files Never to Edit Manually

- `src/lib/supabase/types.gen.ts` — always regenerated by `npm run db:types`
- `src/components/ui/*.tsx` — shadcn/ui components, always added/updated via `npx shadcn@latest add`
- `android/` — managed by Capacitor, always updated via `npx cap sync`

---

## Key Invariants (things that must always be true)

1. `sum(expense_splits.amount) === expenses.total_amount` for every expense
2. `sum(expense.split.basisPoints) === 10000` for every percentage split
3. No balance columns exist in any database table
4. Every user-visible string goes through `t('key')` — no hardcoded strings
5. `src/domain/` has zero imports from outside itself
6. Expense + splits are always written in a single Postgres transaction (via RPC)
